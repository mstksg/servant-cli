-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Command line interface for Servant API clients
--   
--   Parse command line arguments into a servant client, from a servant
--   API, using <i>optparse-applicative</i> for parsing, displaying help,
--   and auto-completion.
--   
--   Hooks into the annotation system used by <i>servant-docs</i> to
--   provide descriptions for parameters and captures.
--   
--   See <tt>example/greet.hs</tt> for an example usage, and the
--   <a>README</a> for a tutorial.
@package servant-cli
@version 0.1.0.0


-- | Internal module providing a data structure for representing structure
--   of command line parsers that can be manipulated as an ADT, as well as
--   functionality to interpret it as a <a>Parser</a> command line argument
--   parser.
module Servant.CLI.PStruct

-- | How to "read" an option.
data OptRead :: Type -> Type
[ORRequired] :: ReadM a -> OptRead a
[OROptional] :: ReadM a -> OptRead (Maybe a)
[ORSwitch] :: OptRead Bool

-- | Query parameters are interpreted as options
data Opt a
Opt :: String -> String -> String -> Maybe (NonEmpty String) -> Coyoneda OptRead a -> Opt a
[optName] :: Opt a -> String
[optDesc] :: Opt a -> String
[optMeta] :: Opt a -> String
[optVals] :: Opt a -> Maybe (NonEmpty String)
[optRead] :: Opt a -> Coyoneda OptRead a

-- | Captures are interpreted as arguments
data Arg a
Arg :: String -> String -> String -> ReadM a -> Arg a
[argName] :: Arg a -> String
[argDesc] :: Arg a -> String
[argMeta] :: Arg a -> String
[argRead] :: Arg a -> ReadM a

-- | Interpret an <a>Arg</a> as something that can be given repeatedly an
--   arbitrary number of times.
data MultiArg :: Type -> Type
[MultiArg] :: Arg a -> MultiArg [a]

-- | Captures can be a single capture leading to the next level, or a
--   multi-capture leading to an endpoint action.
type Captures = Day Arg PStruct :+: Day MultiArg EndpointMap

-- | Endpoint arguments and body.
data Endpoint a
Endpoint :: Day (Ap Opt) Parser a -> Endpoint a
[epStruct] :: Endpoint a -> Day (Ap Opt) Parser a

-- | A map of endpoints associated with methods, paired with an optional
--   "raw" endpoint.
data EndpointMap a
EPM :: Map Method (Endpoint a) -> Maybe (Endpoint (Method -> a)) -> EndpointMap a
[epmGiven] :: EndpointMap a -> Map Method (Endpoint a)
[epmRaw] :: EndpointMap a -> Maybe (Endpoint (Method -> a))

-- | Structure for a parser of a given value that may use items from
--   captures and arguments.
data PStruct a
PStruct :: [String] -> Map String (PStruct a) -> Maybe (Captures a) -> EndpointMap a -> PStruct a
[psInfo] :: PStruct a -> [String]

-- | path components
[psComponents] :: PStruct a -> Map String (PStruct a)

-- | captures
[psCaptures] :: PStruct a -> Maybe (Captures a)
[psEndpoints] :: PStruct a -> EndpointMap a
data PStructF (a_ag88 :: Type) r_ahbt
PStructF :: [[Char]] -> Map [Char] r_ahbt -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_ag88) -> EndpointMap a_ag88 -> PStructF r_ahbt
[psInfoF] :: PStructF r_ahbt -> [[Char]]
[psComponentsF] :: PStructF r_ahbt -> Map [Char] r_ahbt
[psCapturesF] :: PStructF r_ahbt -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_ag88)
[psEndpointsF] :: PStructF r_ahbt -> EndpointMap a_ag88

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | Low-level implementation of <a>structParser</a>.
structParser_ :: PStruct a -> Bool -> [String] -> InfoMod a -> ParserInfo a

-- | Combine two <a>PStruct</a>s in an either-or fashion, favoring the left
--   hand side.
branch :: PStruct a -> PStruct b -> PStruct (Either a b)
infixr 3 `branch`

-- | Shift by a path component.
($:>) :: String -> PStruct a -> PStruct a
infixr 4 $:>

-- | Add a request body to all endpoints.
--   
--   If done more than once per endpoint, it runs *both* parsers; however,
--   we can only send one request body, so this is undefined behavior as a
--   client.
(%:>) :: Parser a -> PStruct (a -> b) -> PStruct b
infixr 4 %:>

-- | Add a command-line option to all endpoints.
(?:>) :: Opt a -> PStruct (a -> b) -> PStruct b
infixr 4 ?:>

-- | Add a single argument praser.
(#:>) :: Arg a -> PStruct (a -> b) -> PStruct b
infixr 4 #:>

-- | Add a repeating argument parser.
(##:>) :: Arg a -> PStruct ([a] -> b) -> PStruct b
infixr 4 ##:>

-- | Add notes to the beginning of a documentation level.
note :: [String] -> PStruct a -> PStruct a
infixr 4 `note`

-- | Create an endpoint action.
endpoint :: Method -> a -> PStruct a

-- | Create a raw endpoint.
rawEndpoint :: (Method -> a) -> PStruct a

-- | Helper to lift a <a>ReadM</a> into something that can be used with
--   <a>optRead</a>.
orRequired :: ReadM a -> Coyoneda OptRead a

-- | Helper to lift an optional <a>ReadM</a> into something that can be
--   used with <a>optRead</a>.
orOptional :: ReadM a -> Coyoneda OptRead (Maybe a)

-- | An <a>optRead</a> that is on-or-off.
orSwitch :: Coyoneda OptRead Bool
instance Data.Traversable.Traversable (Servant.CLI.PStruct.PStructF a)
instance Data.Foldable.Foldable (Servant.CLI.PStruct.PStructF a)
instance GHC.Base.Functor (Servant.CLI.PStruct.PStructF a)
instance Data.Functor.Foldable.Recursive (Servant.CLI.PStruct.PStruct a)
instance Data.Functor.Foldable.Corecursive (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Semigroup (Servant.CLI.PStruct.EndpointMap a)
instance GHC.Base.Monoid (Servant.CLI.PStruct.EndpointMap a)
instance GHC.Base.Semigroup (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Monoid (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Functor Servant.CLI.PStruct.PStruct
instance GHC.Base.Functor Servant.CLI.PStruct.EndpointMap
instance GHC.Base.Functor Servant.CLI.PStruct.Endpoint
instance GHC.Base.Functor Servant.CLI.PStruct.Arg
instance GHC.Base.Functor Servant.CLI.PStruct.Opt


-- | Provides the interface for <a>ParseBody</a>, a helper class for
--   defining directly how to parse request bodies.
module Servant.CLI.ParseBody

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
--   
--   You need an instance of this for every type you use with
--   <tt>ReqBody</tt>.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a

-- | Default implementation that expects a <tt>--data</tt> option.
defaultParseBody :: String -> ReadM a -> Parser a
instance Servant.CLI.ParseBody.ParseBody Data.Text.Internal.Text
instance Servant.CLI.ParseBody.ParseBody Data.Text.Internal.Lazy.Text
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Int
instance Servant.CLI.ParseBody.ParseBody GHC.Integer.Type.Integer
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Float
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Double


-- | Main module providing underlying functionality for the command line
--   interface parser for servant API clients.
--   
--   For the most part, you can ignore this module unless you're adding new
--   API combinators.
module Servant.CLI.HasCLI

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Note that query parameters and captures all require
--   <i>servant-docs</i> annotation instances, to allow for proper help
--   messages.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api ctx where {
    
    -- | The parsed type of the client request response. Usually this will be a
    --   bunch of nested <a>Either</a>s for every API endpoint, nested
    --   according to the <a>:&lt;|&gt;</a>s in the API.
    type family CLIResult (m :: Type -> Type) (api :: Type) :: Type;
    
    -- | The type of a data structure to conveniently handle the results of all
    --   pontential endpoints. This is useful because it is often tedious to
    --   handle the bunch of nested <a>Either</a>s that <a>CLIResult</a> has.
    --   
    --   It essentially lets you specify how to sort each potential endpoint's
    --   response into a single output value.
    --   
    --   Usually this will be a bunch of nested <a>:&lt;|&gt;</a>s which handle
    --   each endpoint, according to the <a>:&lt;|&gt;</a>s in the API. It
    --   mirrors the structure of <a>Client</a> and <a>ServerT</a>.
    --   
    --   Used with functions like <tt>parseHandleClient</tt>.
    type family CLIHandler (m :: Type -> Type) (api :: Type) (r :: Type) :: Type;
}

-- | Generate a <a>PStruct</a> showing how to modify a <a>Request</a> and
--   perform an action, given an API and underlying monad. Only meant for
--   internal use; should be used through <a>cliPStruct</a> instead.
--   
--   Takes a <a>Rec</a> of actions to generate required items that cannot
--   be passed via the command line (like authentication). Pass in
--   <a>RNil</a> if no parameters are expected (that is, if
--   <tt><tt>CLIContext</tt> m api</tt> is an empty list). The actions will
--   only be run if they are needed.
cliPStructWithContext_ :: HasCLI m api ctx => Proxy m -> Proxy api -> Rec (ContextFor m) ctx -> PStruct (Request -> m (CLIResult m api))

-- | Handle all the possibilities in a <a>CLIResult</a>, by giving the
--   appropriate <a>CLIHandler</a>.
cliHandler :: HasCLI m api ctx => Proxy m -> Proxy api -> Proxy ctx -> CLIHandler m api r -> CLIResult m api -> r
data family ContextFor (m :: Type -> Type) :: Type -> Type

-- | Contains a subcontext that can be descended down into using
--   <a>NamedContext</a>. Mirrors <a>NamedContext</a>.
--   
--   Useful for when you have multiple items with the same name within a
--   context; this essentially creates a namespace for context items.
newtype NamedContext m (name :: Symbol) (subContext :: [Type])
NamedContext :: Rec (ContextFor m) subContext -> NamedContext m

-- | Allows you to access <a>NamedContext</a>s inside a context.
descendIntoNamedContext :: forall (name :: Symbol) context subContext m. NamedContext m name subContext ∈ context => Proxy name -> Rec (ContextFor m) context -> Rec (ContextFor m) subContext
instance (Servant.CLI.HasCLI.NamedContext m name subctx Data.Vinyl.Lens.∈ ctx, Servant.CLI.HasCLI.HasCLI m subapi subctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.WithNamedContext.WithNamedContext name subctx subapi) ctx
instance Servant.CLI.HasCLI.HasCLI m Servant.API.Empty.EmptyAPI ctx
instance (Servant.CLI.HasCLI.HasCLI m a ctx, Servant.CLI.HasCLI.HasCLI m b ctx, GHC.Base.Functor m) => Servant.CLI.HasCLI.HasCLI m (a Servant.API.Alternative.:<|> b) ctx
instance (GHC.TypeLits.KnownSymbol path, Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (path Servant.API.Sub.:> api) ctx
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture sym a), Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> api) ctx
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.CaptureAll sym a), Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Capture.CaptureAll sym a Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods sym a), Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol sym, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryFlag sym), Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api) ctx
instance (Servant.API.ContentTypes.MimeRender ct a, Servant.CLI.ParseBody.ParseBody a, Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api) ctx
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.Types.Nat) (cts' :: [*]) a (ctx :: [*]). (Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a), Servant.API.Verbs.ReflectMethod method) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Verbs.Verb method status cts' a) ctx
instance forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (status :: GHC.Types.Nat) (ctx :: [*]). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Stream.Stream method status framing ct a) ctx
instance (Servant.API.Stream.ToSourceIO chunk a, Servant.API.ContentTypes.MimeRender ctype chunk, Servant.API.Stream.FramingRender framing, Servant.API.Stream.StreamBody' mods framing ctype a Data.Vinyl.Lens.∈ ctx, Servant.CLI.HasCLI.HasCLI m api ctx, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Stream.StreamBody' mods framing ctype a Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api) ctx
instance Servant.CLI.HasCLI.HasCLI m api ctx => Servant.CLI.HasCLI.HasCLI m (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Description.Summary desc Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.HasCLI.HasCLI m api ctx) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Description.Description desc Servant.API.Sub.:> api) ctx
instance Servant.Client.Core.RunClient.RunClient m => Servant.CLI.HasCLI.HasCLI m Servant.API.Raw.Raw ctx
instance Servant.CLI.HasCLI.HasCLI m api ctx => Servant.CLI.HasCLI.HasCLI m (Data.Vault.Lazy.Vault Servant.API.Sub.:> api) ctx
instance Servant.CLI.HasCLI.HasCLI m api ctx => Servant.CLI.HasCLI.HasCLI m (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api) ctx
instance Servant.CLI.HasCLI.HasCLI m api ctx => Servant.CLI.HasCLI.HasCLI m (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api) ctx
instance forall k (m :: * -> *) api (ctx :: [*]) (tag :: k). (Servant.CLI.HasCLI.HasCLI m api ctx, Servant.API.Experimental.Auth.AuthProtect tag Data.Vinyl.Lens.∈ ctx, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api) ctx
instance (Servant.Docs.Internal.ToAuthInfo (Servant.API.BasicAuth.BasicAuth realm usr), Servant.CLI.HasCLI.HasCLI m api ctx, Servant.API.BasicAuth.BasicAuth realm usr Data.Vinyl.Lens.∈ ctx, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api) ctx


-- | Parse command line arguments into a servant client, from a servant
--   API.
--   
--   Mainly used through <a>parseClient</a> and <a>parseHandleClient</a>.
--   <a>parseClient</a> returns a servant client action that returns nested
--   <a>Either</a>s for every endpoint, but <a>parseHandleClient</a> allows
--   you to conveniently specify how you want to sort each endpoint entry
--   into a single result.
--   
--   See <a>README</a> for a tutorial.
module Servant.CLI

-- | Parse a servant client; the result can be run. The choice of
--   <tt>m</tt> gives the backend you are using; for example, the default
--   GHC <i>servant-client</i> backend is <a>ClientM</a>.
--   
--   Returns the request response, which is usually a layer of
--   <a>Either</a> for every endpoint branch. You can find the response
--   type directly by using typed holes or asking ghci with <tt>:t</tt> or
--   <tt>:kind! forall m. CLIResult m MyAPI</tt>. Because it might be
--   tedious handling nested <a>Either</a>s, see <a>parseHandleClient</a>
--   for a way to handle each potential branch in a convenient way.
--   
--   Takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
parseClient :: HasCLI m api '[] => Proxy api -> Proxy m -> InfoMod (m (CLIResult m api)) -> IO (m (CLIResult m api))

-- | Parse a server client, like <a>parseClient</a>. However, instead of
--   that client action returning the request response, instead use a
--   <a>CLIHandler</a> to handle every potential request response. It
--   essentially lets you specify how to sort each potential endpoint's
--   response into a single output value.
--   
--   The handler is usually a <a>:&lt;|&gt;</a> for every endpoint branch.
--   You can find it by using typed holes or asking ghci with <tt>:t</tt>
--   or <tt>:kind! forall m r. CLIHandler m MyAPI r</tt>.
--   
--   Takes a <a>Rec</a> of actions to generate required items that cannot
--   be passed via the command line (like authentication). Pass in
--   <a>RNil</a> if no context is expected (that is, if
--   <tt><tt>CLIContext</tt> m api</tt> is an empty list), or use
--   <tt>parseHandleClient'</tt>. The actions will only be run if they are
--   needed.
--   
--   Takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
parseHandleClient :: (HasCLI m api '[], Functor m) => Proxy api -> Proxy m -> InfoMod (m (CLIResult m api)) -> CLIHandler m api r -> IO (m r)

-- | A version of <a>parseClient</a> that can be used if the API requires
--   any external context to generate runtime data.
parseClientWithContext :: HasCLI m api context => Proxy api -> Proxy m -> Rec (ContextFor m) context -> InfoMod (m (CLIResult m api)) -> IO (m (CLIResult m api))

-- | A version of <a>parseHandleClient</a> that can be used if the API
--   requires any external context to generate runtime data.
parseHandleClientWithContext :: forall m api context r. (HasCLI m api context, Functor m) => Proxy api -> Proxy m -> Rec (ContextFor m) context -> InfoMod (m (CLIResult m api)) -> CLIHandler m api r -> IO (m r)

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Note that query parameters and captures all require
--   <i>servant-docs</i> annotation instances, to allow for proper help
--   messages.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api ctx where {
    
    -- | The parsed type of the client request response. Usually this will be a
    --   bunch of nested <a>Either</a>s for every API endpoint, nested
    --   according to the <a>:&lt;|&gt;</a>s in the API.
    type family CLIResult (m :: Type -> Type) (api :: Type) :: Type;
    
    -- | The type of a data structure to conveniently handle the results of all
    --   pontential endpoints. This is useful because it is often tedious to
    --   handle the bunch of nested <a>Either</a>s that <a>CLIResult</a> has.
    --   
    --   It essentially lets you specify how to sort each potential endpoint's
    --   response into a single output value.
    --   
    --   Usually this will be a bunch of nested <a>:&lt;|&gt;</a>s which handle
    --   each endpoint, according to the <a>:&lt;|&gt;</a>s in the API. It
    --   mirrors the structure of <a>Client</a> and <a>ServerT</a>.
    --   
    --   Used with functions like <tt>parseHandleClient</tt>.
    type family CLIHandler (m :: Type -> Type) (api :: Type) (r :: Type) :: Type;
}

-- | Handle all the possibilities in a <a>CLIResult</a>, by giving the
--   appropriate <a>CLIHandler</a>.
cliHandler :: HasCLI m api ctx => Proxy m -> Proxy api -> Proxy ctx -> CLIHandler m api r -> CLIResult m api -> r
data family ContextFor (m :: Type -> Type) :: Type -> Type

-- | Contains a subcontext that can be descended down into using
--   <a>NamedContext</a>. Mirrors <a>NamedContext</a>.
--   
--   Useful for when you have multiple items with the same name within a
--   context; this essentially creates a namespace for context items.
newtype NamedContext m (name :: Symbol) (subContext :: [Type])
NamedContext :: Rec (ContextFor m) subContext -> NamedContext m

-- | Allows you to access <a>NamedContext</a>s inside a context.
descendIntoNamedContext :: forall (name :: Symbol) context subContext m. NamedContext m name subContext ∈ context => Proxy name -> Rec (ContextFor m) context -> Rec (ContextFor m) subContext

-- | Create a structure for a command line parser.
cliPStruct :: HasCLI m api '[] => Proxy m -> Proxy api -> PStruct (m (CLIResult m api))

-- | A version of <a>cliPStruct</a> that can be used if the API requires
--   any external context to generate runtime data.
cliPStructWithContext :: HasCLI m api context => Proxy m -> Proxy api -> Rec (ContextFor m) context -> PStruct (m (CLIResult m api))

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
--   
--   You need an instance of this for every type you use with
--   <tt>ReqBody</tt>.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a

-- | Default implementation that expects a <tt>--data</tt> option.
defaultParseBody :: String -> ReadM a -> Parser a

-- | The class that helps us automatically get documentation for URL
--   captures.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   </pre>
class ToCapture (c :: k)
toCapture :: ToCapture c => Proxy c -> DocCapture

-- | A type to represent captures. Holds the name of the capture and a
--   description.
--   
--   Write a <a>ToCapture</a> instance for your captured types.
data DocCapture
DocCapture :: String -> String -> DocCapture
[_capSymbol] :: DocCapture -> String
[_capDesc] :: DocCapture -> String

-- | The class that helps us automatically get documentation for GET (or
--   other <a>Method</a>) parameters.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToParam (QueryParam' mods "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   </pre>
class ToParam (t :: k)
toParam :: ToParam t => Proxy t -> DocQueryParam

-- | A type to represent a <i>GET</i> (or other possible <a>Method</a>)
--   parameter from the Query String. Holds its name, the possible values
--   (leave empty if there isn't a finite number of them), and a
--   description of how it influences the output or behavior.
--   
--   Write a <a>ToParam</a> instance for your GET parameter types
data DocQueryParam
DocQueryParam :: String -> [String] -> String -> ParamKind -> DocQueryParam
[_paramName] :: DocQueryParam -> String
[_paramValues] :: DocQueryParam -> [String]
[_paramDesc] :: DocQueryParam -> String
[_paramKind] :: DocQueryParam -> ParamKind

-- | Type of GET (or other <a>Method</a>) parameter:
--   
--   <ul>
--   <li>Normal corresponds to <tt>QueryParam</tt>, i.e your usual GET
--   parameter</li>
--   <li>List corresponds to <tt>QueryParams</tt>, i.e GET parameters with
--   multiple values</li>
--   <li>Flag corresponds to <tt>QueryFlag</tt>, i.e a value-less GET
--   parameter</li>
--   </ul>
data ParamKind
Normal :: ParamKind
List :: ParamKind
Flag :: ParamKind

-- | The class that helps us get documentation for authenticated endpoints
class ToAuthInfo (a :: k)
toAuthInfo :: ToAuthInfo a => Proxy a -> DocAuthentication

-- | A type to represent Authentication information about an endpoint.
data DocAuthentication
DocAuthentication :: String -> String -> DocAuthentication
[_authIntro] :: DocAuthentication -> String
[_authDataRequired] :: DocAuthentication -> String
